{"meta":{"title":"CKH'S BLOG","subtitle":"","description":"CKH","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2023-03-25T02:36:46.444Z","updated":"2023-03-25T02:36:46.444Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-03-25T02:40:03.744Z","updated":"2023-03-25T02:40:03.744Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2023-03-26T03:27:32.381Z","updated":"2023-03-26T03:27:32.381Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"------ CKH ------ 关于我：一个普普通通又心怀梦想的少年。"},{"title":"所有标签","date":"2023-03-25T02:39:25.847Z","updated":"2023-03-25T02:39:25.847Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"版本信息","date":"2023-03-29T09:46:45.190Z","updated":"2023-03-29T09:46:45.190Z","comments":false,"path":"logs/index.html","permalink":"http://example.com/logs/index.html","excerpt":"","text":"日期 增加了暗黑模式，修补了一些细节 2023年3月26日 增加了博主信息栏，修改了鼠标光标 2023年3月25日 增加了网站图标，评论功能，增加了日志管理"}],"posts":[{"title":"git上传","slug":"git上传","date":"2023-03-25T03:48:16.368Z","updated":"2023-03-25T05:43:46.559Z","comments":true,"path":"2023/03/25/git上传/","link":"","permalink":"http://example.com/2023/03/25/git%E4%B8%8A%E4%BC%A0/","excerpt":"git的简单上传使用技巧","text":"git的简单上传使用技巧 git简单上传使用技巧1. 添加到暂存区12345//将所有文件添加到暂存区git add *//也可以单独选择文件git add test01.md 2. 添加到缓存区 12//提交暂存区到本地仓库（缓存区），-m 说明信息git commit -m &quot;说明信息&quot; 3.提交12//提交到指定分支git push origin master","categories":[{"name":"技术教程","slug":"技术教程","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"},{"name":"新手教程","slug":"技术教程/新手教程","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}],"author":"CKH"},{"title":"Hello World 你好世界","slug":"hello-world","date":"2023-03-25T00:33:20.851Z","updated":"2023-03-25T05:43:24.898Z","comments":true,"path":"2023/03/25/hello-world/","link":"","permalink":"http://example.com/2023/03/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start test01Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"技术教程","slug":"技术教程","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"},{"name":"新手教程","slug":"技术教程/新手教程","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}],"author":"winter8"},{"title":"算法模板","slug":"算法模板","date":"2023-03-19T05:33:09.262Z","updated":"2023-03-26T06:45:49.356Z","comments":true,"path":"2023/03/19/算法模板/","link":"","permalink":"http://example.com/2023/03/19/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","excerpt":"算法模板🎈","text":"算法模板🎈 目录 数据结构 并查集 字典树 ST表 单点修改线段树 区间修改线段树 MEX数据结构 数论 __int128的输入及输出 线性筛 快速幂 欧拉函数 组合数 图论 bfs dijkstra 判断负环 二分图 最近公共祖先 最小生成树 差分约束 模板 数位dp模板 高精度加减乘除 做题小结 数据结构并查集：12345678910111213const int MAXN = ;init(int n) &#123; for(int i = 1; i &lt;= n; i++) &#123; p[i] = i; &#125;&#125;int find(int x) &#123; if(p[x] != x) return p[x] = find(p[x]); else return x;&#125; 字典树：12345678910111213141516171819202122232425262728293031323334353637//最长字符串长度（*）const int Maxn = 2e6+5; int tree[Maxn][30];bool NodeCnt[Maxn];int idx;//插入字符串str; void insert(string str) &#123; int p = 0; for(auto s:str) &#123; int id = s-&#x27;0&#x27;; if(!tree[p][id]) tree[p][id] = ++idx; root = tree[p][id]; &#125; NodeCnt[p]++; &#125;//寻找字符串str出现次数 int find(string str) &#123; int p = 0; for(auto s:str) &#123; //确认是数字还是字符串（*） int id = s-&#x27;0&#x27;; if(!tree[p][id]) return false; root = tree[p][id]; &#125; return NodeCnt[p];&#125;//清除树 void KillTree() &#123; for(int i = 0; i &lt;= idx; i++) &#123; NodeCnt[i] = 0; //清除的长度（*） for(int j = 0; j &lt; 10; j++) &#123; tree[i][j] = 0; &#125; &#125; idx = 0;&#125; ST表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int logn = 21;//最大区间长度（*）const int maxn = 2000001;int f[maxn][logn + 1], Logn[maxn + 1];inline int read() &#123; // 快读 char c = getchar(); int x = 0, f = 1; while (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123; if (c == &#x27;-&#x27;) f = -1; c = getchar(); &#125; while (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; c = getchar(); &#125; return x * f;&#125;void init() &#123; // 准备工作，初始化 Logn[1] = 0; Logn[2] = 1; for (int i = 3; i &lt; maxn; i++) Logn[i] = Logn[i / 2] + 1;&#125;int main() &#123; init(); //n是长度，m是询问次数（*） int n = read(), m = read(); //f[i][0]存入每个点的初始值（*） for (int i = 1; i &lt;= n; i++) f[i][0] = read(); for (int j = 1; j &lt;= logn; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); // ST表具体实现 for (int i = 1; i &lt;= m; i++) &#123; //输入区间（*） int l = ,r = ; //l 和 r是求值的区间范围 int s = Logn[r - l + 1]; //答案 int sans = max(f[1][s],f[r-(1&lt;&lt;s)+1][s]); printf(&quot;%d\\n&quot;, sans); &#125; return 0;&#125; 单点修改线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//最大长度（*）const int Maxn = ;struct Tree&#123; int l,r; int val; &#125; tr[4*Maxn];//pushup区间更新操作void pushup(int u,int l,int r) &#123; //维护操作，如何维护（*） tr[u].val = tr[l].val + tr[r].val;&#125;void pushup(int u) &#123; pushup(u,u&lt;&lt;1,u&lt;&lt;1|1);&#125;void build(int U,int L,int R)&#123; tr[U].l = L, tr[U].r = R; int mid = L+R &gt;&gt; 1; build(U&lt;&lt;1,L,mid); build(U&lt;&lt;1|1,mid+1,R); //倒回建设 pushup(U);&#125;int query(int U,int L,int R) &#123; if(tr[U].l &gt;= L &amp;&amp; tr[U].r &lt;= R) return tr[u].val; int mid = tr[U].l + tr[U].r &gt;&gt; 1; int res = 0;//最终记录值的 if(L &lt;= mid) res = query(U&lt;&lt;1,L,R); //res += query(U&lt;&lt;1,L,R); if(R &gt;= mid) res = query(U&lt;&lt;1|1,L,R); //res += query(U&lt;&lt;1|1,L,R); return v;&#125;//从U结点开始，对x结点进行修改，修改值为vvoid modify(int U,int x,int v) &#123; if(tr[U].l == tr[U].r) tr[U].val = x; else &#123; int mid = tr[U].l + tr[U].r &gt;&gt; 1; if(x &lt;= mid) modify(U&lt;&lt;1,x,v); else modify(U&lt;&lt;1|1,x,v); pushup(U); &#125;&#125; 区间修改线段树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//最大长度（*）const int Maxn = ;//注意树中数据类型，不开longlong见祖宗struct Tree&#123; int val; &#125; tr[4*Maxn];//pushup区间更新操作void pushup(int u,int l,int r) &#123; //维护操作，如何维护（*） tr[u].val = tr[l].val + tr[r].val;&#125;void pushup(int u) &#123; pushup(u,u&lt;&lt;1,u&lt;&lt;1|1);&#125;void build(int U,int L,int R)&#123; int mid = L+R &gt;&gt; 1; build(U&lt;&lt;1,L,mid); build(U&lt;&lt;1|1,mid+1,R); //倒回建设 pushup(U);&#125;int query(int U,int l,int r,int L,int R) &#123; if(l &gt;= L &amp;&amp; r &lt;= R) return tr[U].val; int mid = l + r &gt;&gt; 1; int res = 0;//最终记录值的 if(L &lt;= mid) res = query(U&lt;&lt;1,L,R); //res += query(U&lt;&lt;1,L,R); if(R &gt;= mid) res = query(U&lt;&lt;1|1,L,R); //res += query(U&lt;&lt;1|1,L,R); return v;&#125;//从U结点开始，l、r是当前区间，L、R是要进行修改的区间,v修改后的值。void modify(int U,int l,int r,int L,int R,int v) &#123; if(l == r) tr[U].val = x; else &#123; int mid = l + r &gt;&gt; 1; if(R &lt;= mid) modify(U&lt;&lt;1,l,mid,L,mid,v); else if(L &gt; mid) modify(U&lt;&lt;1|1,mid+1,r,mid+1,R); else &#123; modify(U&lt;&lt;1,l,mid,L,mid,v); modify(U&lt;&lt;1|1,mid+1,r,mid+1,R,v); &#125; pushup(U); &#125;&#125; MEX数据结构及简化版123456789101112131415161718192021222324252627282930313233343536373839//MEX数据结构struct MEX&#123; set&lt;int&gt;st;//计算 mex int cot[maxnum];//记录数字出现个数 multiset&lt;int&gt;mset;//记录当前区间数字 void init() &#123; //初始化 memset(cot, 0, sizeof(cot)); //复杂度为 nlog(n)所以init一次后，后面直接clear for (int i = 0; i &lt; maxnum; i++) st.insert(i);&#125;void add(int x) &#123;//在数据结构中加入一个数 if (cot[x] == 0) &#123; st.erase(x); &#125; cot[x]++; mset.insert(x);&#125;void del(int x) &#123;//在数据结构中删除一个数 if (cot[x] == 1) &#123; st.insert(x); &#125; cot[x]--; mset.erase(mset.find(x));&#125;int mex() &#123;//求mex return *st.begin();&#125;int size() &#123;//返回数组大小 return mset.size();&#125;void clear() &#123;//清空 while (mset.size()) &#123; del(*mset.begin()); &#125;&#125;&#125;; 1234567891011121314151617181920//简化版（去除删除操作）struct MEX&#123; int cot[maxnum]; vector&lt;int&gt;res; int id = 0; void add(int x) &#123; res.push_back(x); cot[x]++; &#125; int mex() &#123; while (cot[id])id++; return id; &#125; void clear() &#123; id = 0; for (int x : res) cot[x]--; res.clear(); &#125;&#125;; 数论__int128的输入和输出12345678910inline __int128 read()&#123;//输入 __int128 x = 0, f = 1;char ch = getchar(); while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)&#123;if(ch == &#x27;-&#x27;)f = -1;ch = getchar();&#125; while(ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;)&#123;x = x * 10 + ch - &#x27;0&#x27;;ch = getchar();&#125; return x * f;&#125;inline void print(__int128 x)&#123;//输出 if(x &lt; 0)&#123;putchar(&#x27;-&#x27;);x = -x;&#125; if(x &gt; 9)print(x / 10);putchar(x % 10 + &#x27;0&#x27;);&#125; 线性筛 时间复杂度：O(n) 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;const int N = 1e6+10;int pr[N];bool st[N];//主要限制条件在于空间复杂度int main()&#123; int n = 1e6; //范围 st[1] = 1; for(int i = 2;i&lt;=n;++i) &#123; if(!st[i]) pr[++cnt] = i; for(int j = 1;pr[j]&lt;=n/i;++j) &#123; st[pr[j]*i] = 1; if(i%pr[j] == 0) break; &#125; &#125; //欧拉筛求完后，pr数组中存储的是1-n所有质数。&#125; 快速幂12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;typedef long long ll;const int mod = __;ll FastPower(ll base, ll power)&#123; ll result = 1; while(power) &#123; if(power &amp; 1) &#123; result = result * base % mod; &#125; power = power &gt;&gt; 1; base = (base * base) % mod; &#125; return result % mod;//此处会卡数据，所以一定要%p&#125;int main()&#123; int base, power; cin &gt;&gt; base &gt;&gt; power; cout &lt;&lt; FastPower(base, power);&#125; 整数分块：求1-n floor(n/i)*i –向下取整 123456789101112int block(int st, int ed, int num) &#123; //sum(num/i i in [st,ed]) int L = 0; int _ans = 0; ed = min(ed, num); //每一个块num/i值是一样的（向下取整） for (int i = st; i &lt;= ed; i = L + 1) &#123; L = min(ed,num / (num / i)); //该区间的最后一个数 _ans += (L - i + 1)*(num / i);//区间[i,L]的num/i 都是一个值 &#125; return _ans;&#125; 整数分块 –向上取整 12345678910111213int block(int st, int ed, int num) &#123; int L = 0; int _ans = 0; ed = min(ed, num); //每一个块num/i值是一样的（向上取整） for (int i = st; i &lt;= ed; i = L + 1) &#123; //需特判f不等于1 int f = (num+i-1)/i; L = min(ed,(num-1) / (f-1)); //该区间的最后一个数 _ans += (L - i + 1)*(f);//区间[i,L]的num/i 都是一个值 &#125; return _ans;&#125; 求欧拉函数1.埃氏筛法(时间换空间的方法) 时间复杂度O($n*\\ln_{}{ln_{}{a}} $)12345678910111213141516171819void euler(int n)&#123; for (int i=1;i&lt;=n;i++) phi[i]=i; for (int i=2;i&lt;=n;i++) &#123; if (phi[i]==i)//这代表i是质数 &#123; for (int j=i;j&lt;=n;j+=i) &#123; phi[j]=phi[j]/i*(i-1); //把i的倍数更新掉， //因为该数 j 为质数的倍数 所以质因子只有该质数 i //通过 在 1 到 该质数 j 中， 去除所有 i 的倍数 //所以phi[j] - phi[j]/i; &#125; &#125; &#125;&#125; 2.欧拉筛法(空间换时间方法) 时间复杂度O(n); 虽然空间复杂度达到了S(3*N) 但是时间复杂为 O(n); 12345678910111213141516171819202122232425void euler(int n)&#123; for(int i = 2; i &lt;= n; ++ i) &#123; if(!st[i]) &#123; primes[++ cnt] = i; phi[i] = i-1; &#125; for(int j = 1; primes[j] &lt;= n/i; ++ j) &#123; int p = primes[j]; st[ i*p ] = true; if(i%p == 0) &#123; phi[ i*p ] = phi[i] * p; //根据欧拉函数的求法：N*(1-1/p1)*(1-1/p2)...*(1-1/pn); //而当i%P==0时，p为i的最小质因子，因为根据上式可知，求欧拉函数只与质因子是谁有关，与指数的大小无关，所以仅需将上式的N更新即可。 break; &#125; phi[ i*p ] = phi[i] * ( P-1 ); //同理，由于p并非i的质因子，所以需要加一个质因子，公式为phi[i]*(1-1/p)*p 化简后得：phi[i]*(p-1); &#125; &#125;&#125; 3. 求单个数的欧拉函数 时间复杂度 O($n^2$)时间复杂度 O(log n) 空间复杂度 S(1); 123456789101112131415161718192021222324/*总的做法就是： 将res存储c; 然后查找c的所有约数，即能整数res的数，全部去除。 剩下的便是与c互质的数。*/int euler(int c) &#123; int res = c; for (int i = 2; i &lt;= c/i; ++ i) &#123; if (c % i == 0)//查找c的约数 &#123; while (c % i == 0) c /= i //在c中除约数i。 res = res / i * (i - 1); //由 res = res - res/i; 得来。 //求不能约去的数的个数。 &#125; &#125; if (c &gt; 1) res = res / c * (c - 1); //当c还有剩余，则是大于 c^(1/2) 的那个约数，将他在答案中除去。 return res;&#125; 求组合数 公式递推 时间复杂度 O(n^2) 空间复杂度 O(n^2). 适用于 “小规模”、“小范围” 的求法 C(a,b) = C(a,b-1) + C(a-1,b-1) 12345678for(int i = 0; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= i; j++) &#123; if(!j) f[i][j] = 1; else f[i][j] = f[i-1][j-1]+f[i][j-1]; &#125;&#125; 预处理法 时间复杂度 O(nlogp) 空间复杂度 O(n).适用于 “中小规模” 、”中小范围” 的求法 C(a,b) = a!/(b!*(a-b)!) = a!*b!^-1*(a-b)!^-1 12345678910111213141516171819202122232425262728typedef long long ll;int fact[N],infact[N];//定义int inv(int a,int x,int p)//快速幂求逆元&#123; int res = 1; while(x) &#123; if(x&amp;1) res = (ll) res * a % p; a = (ll) a*a%p;//(ll) x&gt;&gt;=1; &#125; return res;&#125;int main()&#123; fact[0] = infact[0] = 1; for(int i = 1;i&lt;N;i++) &#123; fact[i] = (ll) fact[i-1]*i%p; infact[i] = (ll) infact[i-1]*inv(i,p-2,p)%p; &#125;//预处理阶乘值，和逆元。 printf(&quot;%d\\n&quot;,(ll) fact[a]*infact[b]%p*infact[a-b]%p);//输出结果&#125; Lucas定理 ​ 处理大概 p 在 1e5 内的数据量 a,b不限量，但是只能计算20组左右的 数据 ​ 适用于 大范围，小个数 的求法 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;typedef long long ll;int p;int fp(int a,int x)//快速幂&#123; int res = 1; while(x) &#123; if(x &amp; 1) res = (ll) res * a % p; a =(ll) a*a%p; x&gt;&gt;=1; &#125; return res;&#125;int C(int a,int b)//预处理阶乘，逆元。&#123; int res = 1; for(int i = 1,j = a;i&lt;=b;i++,j--) &#123; res = (ll) res * j % p; res = (ll) res * fp(i,p-2) % p; &#125; return res;&#125;int lucas(ll a,ll b)//Lucas定理&#123; if(a&lt;p &amp;&amp; b&lt;p) return C(a,b);//第一种情况比p小，所以直接输出。 return (ll) C(a%p,b%p) * lucas(a/p,b/p) %p;&#125;int main()&#123; ll a,b; cin&gt;&gt; a &gt;&gt; b &gt;&gt; p; cout&lt;&lt;lucas(a,b)&lt;&lt;endl;&#125; 图论bfs1234567891011121314151617181920212223242526272829typedef pair&lt;int,int&gt; PII;int g[N][N];//障碍物int b[N][N];//行走路径int n,m;queue&lt;PII&gt; qu;int bfs()&#123; memset(b,-1,sizeof(b)); qu.push(&#123;0,0&#125;); b[0][0] = 0; int dx[4] = &#123;0,1,0,-1&#125; ,dy[4] = &#123;1,0,-1,0&#125;; while(!qu.empty()) &#123; auto t = qu.front(); for(int i = 0;i&lt;4;i++) &#123; auto x = t.first + dx[i],y = t.second + dy[i]; if(x &gt;= 0 &amp;&amp; x&lt;n &amp;&amp; y &gt;= 0 &amp;&amp; y&lt;m &amp;&amp; !g[x][y] &amp;&amp; b[x][y] == -1) &#123; b[x][y] = b[t.first][t.second] + 1; qu.push(&#123;x,y&#125;); &#125; &#125; qu.pop(); &#125; return b[n-1][m-1];&#125; Dijkstra算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Dijkstra算法：#include &lt;bits/stdc++.h&gt;using namespace std;const int N = __,M = __,INF = 0x3f3f3f3f;//N节点个数，M边数typedef pair&lt;int,int&gt; pii;int dist[N];//求距离bool st[N];//标记是否走过priority_queue&lt;pii&gt; heap;//默认x根堆int h[N],e[M],ne[M],w[M],idx;//链接表存图方式int n,m;//点数，边数void add(int a,int b,int c)//a-&gt;b&#123; w[++idx] = c,e[idx] = b,ne[idx] = h[a],h[a] = idx;&#125;int dijkstra(int bg,int ed)&#123; //确定工具数组初始化 memset(dist,0x3f,sizeof dist); memset(dist,0,sizeof st); //初始化 dist[bg] = 0; heap.push(&#123;dist[bg],bg&#125;); while(heap.size()) &#123; auto t = heap.top(); heap.pop(); int sign = t.second; if(st[sign]) continue; st[sign] = true; for(int i = h[sign]; ~i; i = ne[i]) &#123; int j = e[i]; if(dist[j] &gt; dist[sign] + w[i]) &#123; dist[j] = dist[sign] + w[i]; heap.push(&#123;dist[j],j&#125;); &#125; &#125; &#125; return dist[ed];//返回bg到ed的距离&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; int bg,ed; cin&gt;&gt;bg&gt;&gt;ed;//bg起始点，ed终点 memset(h,-1,sizeof h);//初始化图 while(m--) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,b,c);//a-&gt;b建边 &#125; int t = dijkstra(bg,ed); if(t == INF) cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; else cout&lt;&lt;t&lt;&lt;endl;&#125; 判断负环(dfs+spfa)12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e3+10;vector&lt;pair&lt;int,int&gt; &gt; son[N];int dist[N];int st[N];int n,m;int res;void dfs(int now) &#123; st[now] = 1; for(auto x:son[now]) &#123; int u = x.first,w = x.second; if(dist[u] &gt; dist[now] + w) &#123; dist[u] = dist[now] + w; if(st[u] == 1) &#123; res = true; return; &#125; dfs(u); if(res) return; &#125; &#125; st[now] = 2;&#125; void check() &#123; //检查每个点是否能到达负环。 for(int i = 1; i &lt;= n; i++) &#123; if(st[i]) continue; if(res) return; dfs(i); &#125;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1; i &lt;= m; i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; son[a].push_back(&#123;b,c&#125;); &#125; check(); if(res) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125; 二分图1. bfs染色法（0代表无颜色，1、2分别代表一种颜色）O(M+N)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+10,M = 2e5+10;typedef pair&lt;int,int&gt; pii;int e[M],ne[M],h[N],idx;int n,m;int st[N];//标识是否走过。void add(int a,int b) &#123; e[idx] = b,ne[idx] = h[a],h[a] = idx++;&#125;bool bfs(int u) &#123; queue&lt;pii&gt; qu; qu.push(&#123;u,1&#125;); st[u] = 1; while(qu.size()) &#123; auto t = qu.front(); qu.pop(); int ver = t.first,col = t.second; for(int i = h[ver]; ~i; i = ne[i]) &#123; int j = e[i]; if(!st[j]) &#123; st[j] = 3-c0l; qu.push(&#123;j,3-c0l&#125;); &#125; else if(st[j] == col) return false; &#125; &#125; return true;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; memset(h,-1,sizeof h); while(m--) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; add(a,b),add(b,a); &#125; //对每个点进行bfs，如果 int flag = true; for(int i = 1; i &lt;= n; i++) &#123; if(!st[i]) &#123; if(!bfs(i)) &#123; flag = false; break; &#125; &#125; &#125;&#125; 2. 匈牙利算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;#define x first#define y secondconst int N = 110;typedef pair&lt;int,int&gt; PII;bool g[N][N];//障碍物PII match[N][N];//右组（非匹配组）的对象bool st[N][N];//在find过程中，标记int n,m;int dx[] = &#123;-1,0,1,0&#125;, dy[] = &#123;0,-1,0,1&#125;;bool find(int x,int y)&#123; //对于四个方向进行匹配 for(int i = 0; i &lt; 4; i ++) &#123; int a = x+dx[i],b = y+dy[i]; if(a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= n &amp;&amp; !g[a][b] &amp;&amp; !st[a][b]) &#123; st[a][b] = true; PII &amp;t = match[a][b]; //如果右组不存在匹配对象 或者 可以换匹配对象 if(t.x == -1 || find(t.x,t.y)) &#123; t = &#123;x,y&#125;; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); while(m--) &#123; int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g[x][y] = true; &#125; int res = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) match[i][j] = &#123;-1,-1&#125;; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j ++) &#123; //对于一侧的组进行匹配 if((i+j) % 2 &amp;&amp; !g[i][j]) &#123; for(int a = 1; a &lt;= n; a++) for(int b = 1; b &lt;= n; b++) st[a][b] = 0; //检查是否可以匹配成功 if(find(i,j)) res++; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,res);&#125; 最近公共祖先LCA倍增1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e4+10, M = 2*N;int n,m;int h[N],e[M],ne[M],idx;//depth存储节点的深度int depth[N],fa[N][16];int q[N];void add(int a,int b) &#123; e[idx] = b,ne[idx] = h[a],h[a] = idx++;&#125;void bfs(int root)//使用bfs算法计算出fa&#123; memset(depth,0x3f,sizeof depth); depth[0] = 0,depth[root] = 1; int hh = 0, tt = 0; q[0] = root; while(hh &lt;= tt) &#123; int t = q[hh++]; for(int i = h[t]; ~i; i = ne[i]) &#123; int j = e[i]; if(depth[j] &gt; depth[t] + 1) &#123; //求深度 depth[j] = depth[t] + 1; q[++tt] = j; //初始化fa[j][0]; fa[j][0] = t; //进行遍历 dp状态转移 for(int k = 1; k &lt;= 15; k++) &#123; fa[j][k] = fa[fa[j][k-1]][k-1]; &#125; &#125; &#125; &#125;&#125;int lca(int a,int b)&#123; //将距离根节点远的设置为a if(depth[a] &lt; depth[b]) swap(a,b); for(int k = 15; k &gt;= 0; k--) &#123; //二进制拼凑，使达到同一高度 if(depth[fa[a][k]] &gt;= depth[b]) a = fa[a][k]; &#125; if(a == b) return a;//判断是否为同一个点。 //否则，同时上升直到祖父节点为同一个节点。 for(int k = 15; k &gt;= 0; k--) &#123; if(fa[a][k] != fa[b][k]) &#123; a = fa[a][k]; b = fa[b][k]; &#125; &#125; return fa[a][0];&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); int root = 0; memset(h,-1,sizeof h); for(int i = 1; i &lt;= n; i++) &#123; int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); if(b == -1) root = a; else add(a,b),add(b,a); &#125; bfs(root); int p = lca(a,b); return 0;&#125; tarjan最近公共祖先1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pii;const int N = 10010,M = N*2;int n,m;int h[N],e[M],w[M],ne[M],idx;int dist[N];int res[M];int st[N];int p[N];vector&lt;pii&gt; query[N];void add(int a,int b,int c) &#123; w[idx] = c,e[idx] = b,ne[idx] = h[a],h[a] = idx++;&#125;void dfs(int u,int fa) &#123; for(int i = h[u]; ~i; i = ne[i]) &#123; int j = e[i]; if(j == fa) continue; //利用dfs计算dist来进行计算距离 dist[j] = dist[u] + w[i]; dfs(j,u); &#125;&#125;int find(int x) &#123; if(p[x] != x) p[x] = find(p[x]); return p[x];&#125;void tarjan(int u) &#123; //当前未回溯节点 st[u] = 1; for(int i = h[u]; ~i; i = ne[i]) &#123; int j = e[i]; if(!st[j]) &#123; tarjan(j); p[j] = u; &#125; &#125; //需要cha for(auto item:query[u]) &#123; int y = item.first,id = item.second; if(st[y] == 2) &#123; int p = find(y); //u和y的lca是p &#125; &#125; //已经回溯节点 st[u] = 2;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; memset(h,-1,sizeof h); for(int i = 1; i &lt; n; i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,b,c),add(b,a,c); &#125; for(int i = 1; i &lt;= m; i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; if(a != b) &#123; query[a].push_back(&#123;b,i&#125;); query[b].push_back(&#123;a,i&#125;); &#125; &#125; //初始化并查集 for(int i = 1; i &lt;= n; i++) p[i] = i; dfs(1,-1); tarjan(1); return 0;&#125; 最小生成树 kruskal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4+10;struct Edge&#123; int from,to,s;&#125; edge[N];int cnt;int n,p[N],ans;bool cmp(Edge a,Edge b)&#123; return a.s &lt; b.s;&#125;int find(int x)&#123; if(p[x] != x) return p[x] = find(p[x]); else return x;&#125;int main()&#123; cin&gt;&gt;n; int x; for(int i = 1; i &lt;= n; i++) p[i] = i; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) &#123; scanf(&quot;%d&quot;,&amp;x); if(i &gt; j) &#123; edge[++cnt].from = i; edge[cnt].to = j; edge[cnt].s = x; &#125; &#125; sort(edge+1,edge+cnt+1,cmp); for(int i = 1; i &lt;= cnt; i++) &#123; int a = find(edge[i].from); int b = find(edge[i].to); if(a != b) &#123; ans += edge[i].s; p[a] = b; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 差分约束x1 - x2 &lt;= n 的一系列方程，可以转变为x2到x1的路径最大为n，然后判断负环。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010,M = 300010,INF = 0x3f3f3f3f;typedef long long ll;int h[N],e[M],ne[M],w[M],idx;int dist[N];bool st[N];int stk[N],cnt[N];int n,m;void add(int a,int b,int c)&#123; w[idx] = c,e[idx] = b,ne[idx] = h[a],h[a] = idx++;&#125;bool spfa()&#123; int hh = 0,tt = 0; memset(dist,-0x3f,sizeof dist); dist[0] = 0; stk[tt++] = 0; st[0] = true; while(hh &lt; tt) &#123; int t = stk[--tt]; st[t] = false; for(int i = h[t]; ~i; i = ne[i]) &#123; int j = e[i]; //dist[j] = a dist[t] = b w[i] = n //a &lt; b + n =&gt; a - b &lt; n if(dist[j] &lt; dist[t] + w[i]) &#123; dist[j] = dist[t] + w[i]; cnt[j] = cnt[t]+1; if(cnt[j] &gt;= n+1) return false; if(!st[j]) &#123; stk[tt++] = j; st[j] = true; &#125; &#125; &#125; &#125; return true;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); memset(h,-1,sizeof h); while(m--) &#123; int x,a,b; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;a,&amp;b); if(x == 1) add(a,b,0),add(b,a,0);//a == b else if(x == 2) add(a,b,1);// else if(x == 3) add(b,a,0); else if(x == 4) add(b,a,1); else add(a,b,0); &#125; for(int i = 1; i &lt;= n; i++) &#123; add(0,i,1); &#125; if(spfa()) &#123; ll res = 0; for(int i = 1; i &lt;= n; i++) &#123; res += dist[i]; &#125; printf(&quot;%lld\\n&quot;,res); &#125; else &#123; puts(&quot;-1&quot;); &#125; return 0;&#125; 模板数位dp模板123456789101112131415161718192021222324252627282930int dfs(int pos（位置）, int pre（上一个数）, int lead（前导零）, int limit（是否有限制）) &#123; if (!pos) &#123; return 单条链结束时的返回的值； &#125; if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][pre] != -1) return dp[pos][pre]; //记忆化搜索 int res = 0, up = limit ? a[pos] : 1 】; //up表示能枚举的最高位数 for (int i = 0; i &lt;= up; i ++) &#123; if (不合法条件) continue; res += dfs(pos - 1, 未定参数, lead &amp;&amp; !i, limit &amp;&amp; i == up); &#125; return limit ? res : (lead ? res : dp[pos][sum] = res);&#125;int cal(int x) &#123; memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 进制, x /= 进制; return dfs(len, 未定参数, 1, 1);&#125;signed main() &#123; cin &gt;&gt; l &gt;&gt; r; //先计算1-r的数量，然后计算1-l-1的数量，最后相减。 cout &lt;&lt; cal(r) - cal(l - 1) &lt;&lt; endl;&#125; 高精度加减乘除123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;#define vi vector&lt;int&gt;#define pb(A) push_back(A)vi add(vi A,vi B)&#123; if(A.size() &lt; B.size()) return add(B,A); vi C; int t = 0;//交换媒介 for(int i = 0; i &lt; A.size(); i++) &#123; t += A[i]; if(i &lt; B.size()) t += B[i]; C.pb(t%10); t /= 10; &#125; if(t) C.pb(t);//记得收回余量 return C;&#125;int main()&#123; string a,b; cin&gt;&gt;a&gt;&gt;b; vi A,B; for(int i = a.size()-1; i &gt;= 0; i--) A.pb(a[i]-&#x27;0&#x27;); for(int i = b.size()-1; i &gt;= 0; i--) B.pb(b[i]-&#x27;0&#x27;); vi C = add(A,B); for(int i = C.size()-1; i &gt;= 0; i--) cout&lt;&lt;C[i];&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//高精度减法#include &lt;bits/stdc++.h&gt;using namespace std;#define vi vector&lt;int&gt;#define pb(A) push_back(A)bool cmp(vi A,vi B)&#123; if(A.size() != B.size()) return A.size() &lt; B.size(); for(int i = A.size()-1; i &gt;= 0; i--) &#123; if(A[i] != B[i]) &#123; return A[i] &lt; B[i]; &#125; &#125; return 0;&#125;vi sub(vi A,vi B)&#123; if(cmp(A,B)) return sub(B,A); vi C; int t = 0;//交换媒介 for(int i = 0; i &lt; A.size(); i++) &#123; t = A[i] - t; if(i &lt; B.size()) t = t-B[i]; C.pb((t+10)%10);//保证负数的时候+10 if(t &lt; 0) t = 1; else t = 0; &#125; while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125;int main()&#123; string a,b; cin&gt;&gt;a&gt;&gt;b; vi A,B; for(int i = a.size()-1; i &gt;= 0; i--) A.pb(a[i]-&#x27;0&#x27;); for(int i = b.size()-1; i &gt;= 0; i--) B.pb(b[i]-&#x27;0&#x27;); if(cmp(A,B)) cout&lt;&lt;&#x27;-&#x27;; vi C = sub(A,B); for(int i = C.size()-1; i &gt;= 0; i--) cout&lt;&lt;C[i];&#125; 1234567891011121314151617181920212223242526272829//高精度乘法 大数乘小数#include &lt;bits/stdc++.h&gt;using namespace std;#define vi vector&lt;int&gt;#define pb(A) push_back(A)vi mul(vi A,int B)&#123; vi C; int t = 0;//交换媒介 for(int i = 0; i &lt; A.size(); i++) &#123; t += A[i] * B; C.pb(t%10); t /= 10; &#125; if(t) C.pb(t); while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//注意乘数是0 return C;&#125;int main()&#123; string a; int B; cin&gt;&gt;a&gt;&gt;B; vi A; for(int i = a.size()-1; i &gt;= 0; i--) A.pb(a[i]-&#x27;0&#x27;); vi C = mul(A,B); for(int i = C.size()-1; i &gt;= 0; i--) cout&lt;&lt;C[i];&#125; 12345678910111213141516171819202122232425262728293031323334//高精度除法#include &lt;bits/stdc++.h&gt;using namespace std;#define vi vector&lt;int&gt;#define pb(A) push_back(A)struct ans&#123; vi C; int lastNumCnt;&#125;;struct ans div(vi A,int B)&#123; vi C; int t = 0;//交换媒介 for(int i = 0; i &lt; A.size(); i++)//注意顺序 &#123; t = t*10 + A[i]; C.pb(t/B); t = t%B; &#125; reverse(C.begin(),C.end()); while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//注意乘数是0 return &#123;C,t&#125;;&#125;int main()&#123; string a; int B; cin&gt;&gt;a&gt;&gt;B; vi A; for(int i = 0; i &lt; a.size(); i++) A.pb(a[i]-&#x27;0&#x27;);//注意顺序 auto res = div(A,B); for(int i = res.C.size()-1; i &gt;= 0; i--) cout&lt;&lt;res.C[i]; cout&lt;&lt;&#x27;\\n&#x27;&lt;&lt;res.lastNumCnt;&#125; 做题小结 博弈论题 只看第一步，只看第一步，只看第一步，第一步决胜负！ WA了 如果感觉没错但是代码没过，最好重新证明一下思路是否正确。 如果证明完成后还是正确，那就测试一下特殊样例，或者检查一下细节，包括但不限于，范围，题目中的特殊条件等。 签到题 过的人很多的题，一般是结论题。 字符串子串个数 n*(n+1)/2","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"学习/算法","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"CKH"}],"categories":[{"name":"技术教程","slug":"技术教程","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"},{"name":"新手教程","slug":"技术教程/新手教程","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"学习/算法","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}