{"meta":{"title":"CKH'S BLOG","subtitle":"","description":"CKH","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"æ‰€æœ‰åˆ†ç±»","date":"2023-03-25T02:36:46.444Z","updated":"2023-03-25T02:36:46.444Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-03-25T02:40:03.744Z","updated":"2023-03-25T02:40:03.744Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2023-03-26T03:27:32.381Z","updated":"2023-03-26T03:27:32.381Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"------ CKH ------ å…³äºæˆ‘ï¼šä¸€ä¸ªæ™®æ™®é€šé€šåˆå¿ƒæ€€æ¢¦æƒ³çš„å°‘å¹´ã€‚"},{"title":"æ‰€æœ‰æ ‡ç­¾","date":"2023-03-25T02:39:25.847Z","updated":"2023-03-25T02:39:25.847Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"ç‰ˆæœ¬ä¿¡æ¯","date":"2023-03-29T09:46:45.190Z","updated":"2023-03-29T09:46:45.190Z","comments":false,"path":"logs/index.html","permalink":"http://example.com/logs/index.html","excerpt":"","text":"æ—¥æœŸ å¢åŠ äº†æš—é»‘æ¨¡å¼ï¼Œä¿®è¡¥äº†ä¸€äº›ç»†èŠ‚ 2023å¹´3æœˆ26æ—¥ å¢åŠ äº†åšä¸»ä¿¡æ¯æ ï¼Œä¿®æ”¹äº†é¼ æ ‡å…‰æ ‡ 2023å¹´3æœˆ25æ—¥ å¢åŠ äº†ç½‘ç«™å›¾æ ‡ï¼Œè¯„è®ºåŠŸèƒ½ï¼Œå¢åŠ äº†æ—¥å¿—ç®¡ç†"}],"posts":[{"title":"gitä¸Šä¼ ","slug":"gitä¸Šä¼ ","date":"2023-03-25T03:48:16.368Z","updated":"2023-03-25T05:43:46.559Z","comments":true,"path":"2023/03/25/gitä¸Šä¼ /","link":"","permalink":"http://example.com/2023/03/25/git%E4%B8%8A%E4%BC%A0/","excerpt":"gitçš„ç®€å•ä¸Šä¼ ä½¿ç”¨æŠ€å·§","text":"gitçš„ç®€å•ä¸Šä¼ ä½¿ç”¨æŠ€å·§ gitç®€å•ä¸Šä¼ ä½¿ç”¨æŠ€å·§1. æ·»åŠ åˆ°æš‚å­˜åŒº12345//å°†æ‰€æœ‰æ–‡ä»¶æ·»åŠ åˆ°æš‚å­˜åŒºgit add *//ä¹Ÿå¯ä»¥å•ç‹¬é€‰æ‹©æ–‡ä»¶git add test01.md 2. æ·»åŠ åˆ°ç¼“å­˜åŒº 12//æäº¤æš‚å­˜åŒºåˆ°æœ¬åœ°ä»“åº“ï¼ˆç¼“å­˜åŒºï¼‰ï¼Œ-m è¯´æ˜ä¿¡æ¯git commit -m &quot;è¯´æ˜ä¿¡æ¯&quot; 3.æäº¤12//æäº¤åˆ°æŒ‡å®šåˆ†æ”¯git push origin master","categories":[{"name":"æŠ€æœ¯æ•™ç¨‹","slug":"æŠ€æœ¯æ•™ç¨‹","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"},{"name":"æ–°æ‰‹æ•™ç¨‹","slug":"æŠ€æœ¯æ•™ç¨‹/æ–°æ‰‹æ•™ç¨‹","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"æ•™ç¨‹","slug":"æ•™ç¨‹","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}],"author":"CKH"},{"title":"Hello World ä½ å¥½ä¸–ç•Œ","slug":"hello-world","date":"2023-03-25T00:33:20.851Z","updated":"2023-03-25T05:43:24.898Z","comments":true,"path":"2023/03/25/hello-world/","link":"","permalink":"http://example.com/2023/03/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start test01Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"æŠ€æœ¯æ•™ç¨‹","slug":"æŠ€æœ¯æ•™ç¨‹","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"},{"name":"æ–°æ‰‹æ•™ç¨‹","slug":"æŠ€æœ¯æ•™ç¨‹/æ–°æ‰‹æ•™ç¨‹","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"æ•™ç¨‹","slug":"æ•™ç¨‹","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}],"author":"winter8"},{"title":"ç®—æ³•æ¨¡æ¿","slug":"ç®—æ³•æ¨¡æ¿","date":"2023-03-19T05:33:09.262Z","updated":"2023-03-26T06:45:49.356Z","comments":true,"path":"2023/03/19/ç®—æ³•æ¨¡æ¿/","link":"","permalink":"http://example.com/2023/03/19/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","excerpt":"ç®—æ³•æ¨¡æ¿ğŸˆ","text":"ç®—æ³•æ¨¡æ¿ğŸˆ ç›®å½• æ•°æ®ç»“æ„ å¹¶æŸ¥é›† å­—å…¸æ ‘ STè¡¨ å•ç‚¹ä¿®æ”¹çº¿æ®µæ ‘ åŒºé—´ä¿®æ”¹çº¿æ®µæ ‘ MEXæ•°æ®ç»“æ„ æ•°è®º __int128çš„è¾“å…¥åŠè¾“å‡º çº¿æ€§ç­› å¿«é€Ÿå¹‚ æ¬§æ‹‰å‡½æ•° ç»„åˆæ•° å›¾è®º bfs dijkstra åˆ¤æ–­è´Ÿç¯ äºŒåˆ†å›¾ æœ€è¿‘å…¬å…±ç¥–å…ˆ æœ€å°ç”Ÿæˆæ ‘ å·®åˆ†çº¦æŸ æ¨¡æ¿ æ•°ä½dpæ¨¡æ¿ é«˜ç²¾åº¦åŠ å‡ä¹˜é™¤ åšé¢˜å°ç»“ æ•°æ®ç»“æ„å¹¶æŸ¥é›†ï¼š12345678910111213const int MAXN = ;init(int n) &#123; for(int i = 1; i &lt;= n; i++) &#123; p[i] = i; &#125;&#125;int find(int x) &#123; if(p[x] != x) return p[x] = find(p[x]); else return x;&#125; å­—å…¸æ ‘ï¼š12345678910111213141516171819202122232425262728293031323334353637//æœ€é•¿å­—ç¬¦ä¸²é•¿åº¦ï¼ˆ*ï¼‰const int Maxn = 2e6+5; int tree[Maxn][30];bool NodeCnt[Maxn];int idx;//æ’å…¥å­—ç¬¦ä¸²str; void insert(string str) &#123; int p = 0; for(auto s:str) &#123; int id = s-&#x27;0&#x27;; if(!tree[p][id]) tree[p][id] = ++idx; root = tree[p][id]; &#125; NodeCnt[p]++; &#125;//å¯»æ‰¾å­—ç¬¦ä¸²strå‡ºç°æ¬¡æ•° int find(string str) &#123; int p = 0; for(auto s:str) &#123; //ç¡®è®¤æ˜¯æ•°å­—è¿˜æ˜¯å­—ç¬¦ä¸²ï¼ˆ*ï¼‰ int id = s-&#x27;0&#x27;; if(!tree[p][id]) return false; root = tree[p][id]; &#125; return NodeCnt[p];&#125;//æ¸…é™¤æ ‘ void KillTree() &#123; for(int i = 0; i &lt;= idx; i++) &#123; NodeCnt[i] = 0; //æ¸…é™¤çš„é•¿åº¦ï¼ˆ*ï¼‰ for(int j = 0; j &lt; 10; j++) &#123; tree[i][j] = 0; &#125; &#125; idx = 0;&#125; STè¡¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int logn = 21;//æœ€å¤§åŒºé—´é•¿åº¦ï¼ˆ*ï¼‰const int maxn = 2000001;int f[maxn][logn + 1], Logn[maxn + 1];inline int read() &#123; // å¿«è¯» char c = getchar(); int x = 0, f = 1; while (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123; if (c == &#x27;-&#x27;) f = -1; c = getchar(); &#125; while (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; c = getchar(); &#125; return x * f;&#125;void init() &#123; // å‡†å¤‡å·¥ä½œï¼Œåˆå§‹åŒ– Logn[1] = 0; Logn[2] = 1; for (int i = 3; i &lt; maxn; i++) Logn[i] = Logn[i / 2] + 1;&#125;int main() &#123; init(); //næ˜¯é•¿åº¦ï¼Œmæ˜¯è¯¢é—®æ¬¡æ•°ï¼ˆ*ï¼‰ int n = read(), m = read(); //f[i][0]å­˜å…¥æ¯ä¸ªç‚¹çš„åˆå§‹å€¼ï¼ˆ*ï¼‰ for (int i = 1; i &lt;= n; i++) f[i][0] = read(); for (int j = 1; j &lt;= logn; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); // STè¡¨å…·ä½“å®ç° for (int i = 1; i &lt;= m; i++) &#123; //è¾“å…¥åŒºé—´ï¼ˆ*ï¼‰ int l = ,r = ; //l å’Œ ræ˜¯æ±‚å€¼çš„åŒºé—´èŒƒå›´ int s = Logn[r - l + 1]; //ç­”æ¡ˆ int sans = max(f[1][s],f[r-(1&lt;&lt;s)+1][s]); printf(&quot;%d\\n&quot;, sans); &#125; return 0;&#125; å•ç‚¹ä¿®æ”¹çº¿æ®µæ ‘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//æœ€å¤§é•¿åº¦ï¼ˆ*ï¼‰const int Maxn = ;struct Tree&#123; int l,r; int val; &#125; tr[4*Maxn];//pushupåŒºé—´æ›´æ–°æ“ä½œvoid pushup(int u,int l,int r) &#123; //ç»´æŠ¤æ“ä½œï¼Œå¦‚ä½•ç»´æŠ¤ï¼ˆ*ï¼‰ tr[u].val = tr[l].val + tr[r].val;&#125;void pushup(int u) &#123; pushup(u,u&lt;&lt;1,u&lt;&lt;1|1);&#125;void build(int U,int L,int R)&#123; tr[U].l = L, tr[U].r = R; int mid = L+R &gt;&gt; 1; build(U&lt;&lt;1,L,mid); build(U&lt;&lt;1|1,mid+1,R); //å€’å›å»ºè®¾ pushup(U);&#125;int query(int U,int L,int R) &#123; if(tr[U].l &gt;= L &amp;&amp; tr[U].r &lt;= R) return tr[u].val; int mid = tr[U].l + tr[U].r &gt;&gt; 1; int res = 0;//æœ€ç»ˆè®°å½•å€¼çš„ if(L &lt;= mid) res = query(U&lt;&lt;1,L,R); //res += query(U&lt;&lt;1,L,R); if(R &gt;= mid) res = query(U&lt;&lt;1|1,L,R); //res += query(U&lt;&lt;1|1,L,R); return v;&#125;//ä»Uç»“ç‚¹å¼€å§‹ï¼Œå¯¹xç»“ç‚¹è¿›è¡Œä¿®æ”¹ï¼Œä¿®æ”¹å€¼ä¸ºvvoid modify(int U,int x,int v) &#123; if(tr[U].l == tr[U].r) tr[U].val = x; else &#123; int mid = tr[U].l + tr[U].r &gt;&gt; 1; if(x &lt;= mid) modify(U&lt;&lt;1,x,v); else modify(U&lt;&lt;1|1,x,v); pushup(U); &#125;&#125; åŒºé—´ä¿®æ”¹çº¿æ®µæ ‘12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//æœ€å¤§é•¿åº¦ï¼ˆ*ï¼‰const int Maxn = ;//æ³¨æ„æ ‘ä¸­æ•°æ®ç±»å‹ï¼Œä¸å¼€longlongè§ç¥–å®—struct Tree&#123; int val; &#125; tr[4*Maxn];//pushupåŒºé—´æ›´æ–°æ“ä½œvoid pushup(int u,int l,int r) &#123; //ç»´æŠ¤æ“ä½œï¼Œå¦‚ä½•ç»´æŠ¤ï¼ˆ*ï¼‰ tr[u].val = tr[l].val + tr[r].val;&#125;void pushup(int u) &#123; pushup(u,u&lt;&lt;1,u&lt;&lt;1|1);&#125;void build(int U,int L,int R)&#123; int mid = L+R &gt;&gt; 1; build(U&lt;&lt;1,L,mid); build(U&lt;&lt;1|1,mid+1,R); //å€’å›å»ºè®¾ pushup(U);&#125;int query(int U,int l,int r,int L,int R) &#123; if(l &gt;= L &amp;&amp; r &lt;= R) return tr[U].val; int mid = l + r &gt;&gt; 1; int res = 0;//æœ€ç»ˆè®°å½•å€¼çš„ if(L &lt;= mid) res = query(U&lt;&lt;1,L,R); //res += query(U&lt;&lt;1,L,R); if(R &gt;= mid) res = query(U&lt;&lt;1|1,L,R); //res += query(U&lt;&lt;1|1,L,R); return v;&#125;//ä»Uç»“ç‚¹å¼€å§‹ï¼Œlã€ræ˜¯å½“å‰åŒºé—´ï¼ŒLã€Ræ˜¯è¦è¿›è¡Œä¿®æ”¹çš„åŒºé—´,vä¿®æ”¹åçš„å€¼ã€‚void modify(int U,int l,int r,int L,int R,int v) &#123; if(l == r) tr[U].val = x; else &#123; int mid = l + r &gt;&gt; 1; if(R &lt;= mid) modify(U&lt;&lt;1,l,mid,L,mid,v); else if(L &gt; mid) modify(U&lt;&lt;1|1,mid+1,r,mid+1,R); else &#123; modify(U&lt;&lt;1,l,mid,L,mid,v); modify(U&lt;&lt;1|1,mid+1,r,mid+1,R,v); &#125; pushup(U); &#125;&#125; MEXæ•°æ®ç»“æ„åŠç®€åŒ–ç‰ˆ123456789101112131415161718192021222324252627282930313233343536373839//MEXæ•°æ®ç»“æ„struct MEX&#123; set&lt;int&gt;st;//è®¡ç®— mex int cot[maxnum];//è®°å½•æ•°å­—å‡ºç°ä¸ªæ•° multiset&lt;int&gt;mset;//è®°å½•å½“å‰åŒºé—´æ•°å­— void init() &#123; //åˆå§‹åŒ– memset(cot, 0, sizeof(cot)); //å¤æ‚åº¦ä¸º nlog(n)æ‰€ä»¥initä¸€æ¬¡åï¼Œåé¢ç›´æ¥clear for (int i = 0; i &lt; maxnum; i++) st.insert(i);&#125;void add(int x) &#123;//åœ¨æ•°æ®ç»“æ„ä¸­åŠ å…¥ä¸€ä¸ªæ•° if (cot[x] == 0) &#123; st.erase(x); &#125; cot[x]++; mset.insert(x);&#125;void del(int x) &#123;//åœ¨æ•°æ®ç»“æ„ä¸­åˆ é™¤ä¸€ä¸ªæ•° if (cot[x] == 1) &#123; st.insert(x); &#125; cot[x]--; mset.erase(mset.find(x));&#125;int mex() &#123;//æ±‚mex return *st.begin();&#125;int size() &#123;//è¿”å›æ•°ç»„å¤§å° return mset.size();&#125;void clear() &#123;//æ¸…ç©º while (mset.size()) &#123; del(*mset.begin()); &#125;&#125;&#125;; 1234567891011121314151617181920//ç®€åŒ–ç‰ˆï¼ˆå»é™¤åˆ é™¤æ“ä½œï¼‰struct MEX&#123; int cot[maxnum]; vector&lt;int&gt;res; int id = 0; void add(int x) &#123; res.push_back(x); cot[x]++; &#125; int mex() &#123; while (cot[id])id++; return id; &#125; void clear() &#123; id = 0; for (int x : res) cot[x]--; res.clear(); &#125;&#125;; æ•°è®º__int128çš„è¾“å…¥å’Œè¾“å‡º12345678910inline __int128 read()&#123;//è¾“å…¥ __int128 x = 0, f = 1;char ch = getchar(); while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)&#123;if(ch == &#x27;-&#x27;)f = -1;ch = getchar();&#125; while(ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;)&#123;x = x * 10 + ch - &#x27;0&#x27;;ch = getchar();&#125; return x * f;&#125;inline void print(__int128 x)&#123;//è¾“å‡º if(x &lt; 0)&#123;putchar(&#x27;-&#x27;);x = -x;&#125; if(x &gt; 9)print(x / 10);putchar(x % 10 + &#x27;0&#x27;);&#125; çº¿æ€§ç­› æ—¶é—´å¤æ‚åº¦ï¼šO(n) 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;const int N = 1e6+10;int pr[N];bool st[N];//ä¸»è¦é™åˆ¶æ¡ä»¶åœ¨äºç©ºé—´å¤æ‚åº¦int main()&#123; int n = 1e6; //èŒƒå›´ st[1] = 1; for(int i = 2;i&lt;=n;++i) &#123; if(!st[i]) pr[++cnt] = i; for(int j = 1;pr[j]&lt;=n/i;++j) &#123; st[pr[j]*i] = 1; if(i%pr[j] == 0) break; &#125; &#125; //æ¬§æ‹‰ç­›æ±‚å®Œåï¼Œpræ•°ç»„ä¸­å­˜å‚¨çš„æ˜¯1-næ‰€æœ‰è´¨æ•°ã€‚&#125; å¿«é€Ÿå¹‚12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;typedef long long ll;const int mod = __;ll FastPower(ll base, ll power)&#123; ll result = 1; while(power) &#123; if(power &amp; 1) &#123; result = result * base % mod; &#125; power = power &gt;&gt; 1; base = (base * base) % mod; &#125; return result % mod;//æ­¤å¤„ä¼šå¡æ•°æ®ï¼Œæ‰€ä»¥ä¸€å®šè¦%p&#125;int main()&#123; int base, power; cin &gt;&gt; base &gt;&gt; power; cout &lt;&lt; FastPower(base, power);&#125; æ•´æ•°åˆ†å—ï¼šæ±‚1-n floor(n/i)*i â€“å‘ä¸‹å–æ•´ 123456789101112int block(int st, int ed, int num) &#123; //sum(num/i i in [st,ed]) int L = 0; int _ans = 0; ed = min(ed, num); //æ¯ä¸€ä¸ªå—num/iå€¼æ˜¯ä¸€æ ·çš„ï¼ˆå‘ä¸‹å–æ•´ï¼‰ for (int i = st; i &lt;= ed; i = L + 1) &#123; L = min(ed,num / (num / i)); //è¯¥åŒºé—´çš„æœ€åä¸€ä¸ªæ•° _ans += (L - i + 1)*(num / i);//åŒºé—´[i,L]çš„num/i éƒ½æ˜¯ä¸€ä¸ªå€¼ &#125; return _ans;&#125; æ•´æ•°åˆ†å— â€“å‘ä¸Šå–æ•´ 12345678910111213int block(int st, int ed, int num) &#123; int L = 0; int _ans = 0; ed = min(ed, num); //æ¯ä¸€ä¸ªå—num/iå€¼æ˜¯ä¸€æ ·çš„ï¼ˆå‘ä¸Šå–æ•´ï¼‰ for (int i = st; i &lt;= ed; i = L + 1) &#123; //éœ€ç‰¹åˆ¤fä¸ç­‰äº1 int f = (num+i-1)/i; L = min(ed,(num-1) / (f-1)); //è¯¥åŒºé—´çš„æœ€åä¸€ä¸ªæ•° _ans += (L - i + 1)*(f);//åŒºé—´[i,L]çš„num/i éƒ½æ˜¯ä¸€ä¸ªå€¼ &#125; return _ans;&#125; æ±‚æ¬§æ‹‰å‡½æ•°1.åŸƒæ°ç­›æ³•(æ—¶é—´æ¢ç©ºé—´çš„æ–¹æ³•) æ—¶é—´å¤æ‚åº¦O($n*\\ln_{}{ln_{}{a}} $)12345678910111213141516171819void euler(int n)&#123; for (int i=1;i&lt;=n;i++) phi[i]=i; for (int i=2;i&lt;=n;i++) &#123; if (phi[i]==i)//è¿™ä»£è¡¨iæ˜¯è´¨æ•° &#123; for (int j=i;j&lt;=n;j+=i) &#123; phi[j]=phi[j]/i*(i-1); //æŠŠiçš„å€æ•°æ›´æ–°æ‰ï¼Œ //å› ä¸ºè¯¥æ•° j ä¸ºè´¨æ•°çš„å€æ•° æ‰€ä»¥è´¨å› å­åªæœ‰è¯¥è´¨æ•° i //é€šè¿‡ åœ¨ 1 åˆ° è¯¥è´¨æ•° j ä¸­ï¼Œ å»é™¤æ‰€æœ‰ i çš„å€æ•° //æ‰€ä»¥phi[j] - phi[j]/i; &#125; &#125; &#125;&#125; 2.æ¬§æ‹‰ç­›æ³•(ç©ºé—´æ¢æ—¶é—´æ–¹æ³•) æ—¶é—´å¤æ‚åº¦O(n); è™½ç„¶ç©ºé—´å¤æ‚åº¦è¾¾åˆ°äº†S(3*N) ä½†æ˜¯æ—¶é—´å¤æ‚ä¸º O(n); 12345678910111213141516171819202122232425void euler(int n)&#123; for(int i = 2; i &lt;= n; ++ i) &#123; if(!st[i]) &#123; primes[++ cnt] = i; phi[i] = i-1; &#125; for(int j = 1; primes[j] &lt;= n/i; ++ j) &#123; int p = primes[j]; st[ i*p ] = true; if(i%p == 0) &#123; phi[ i*p ] = phi[i] * p; //æ ¹æ®æ¬§æ‹‰å‡½æ•°çš„æ±‚æ³•ï¼šN*(1-1/p1)*(1-1/p2)...*(1-1/pn); //è€Œå½“i%P==0æ—¶ï¼Œpä¸ºiçš„æœ€å°è´¨å› å­ï¼Œå› ä¸ºæ ¹æ®ä¸Šå¼å¯çŸ¥ï¼Œæ±‚æ¬§æ‹‰å‡½æ•°åªä¸è´¨å› å­æ˜¯è°æœ‰å…³ï¼Œä¸æŒ‡æ•°çš„å¤§å°æ— å…³ï¼Œæ‰€ä»¥ä»…éœ€å°†ä¸Šå¼çš„Næ›´æ–°å³å¯ã€‚ break; &#125; phi[ i*p ] = phi[i] * ( P-1 ); //åŒç†ï¼Œç”±äºpå¹¶éiçš„è´¨å› å­ï¼Œæ‰€ä»¥éœ€è¦åŠ ä¸€ä¸ªè´¨å› å­ï¼Œå…¬å¼ä¸ºphi[i]*(1-1/p)*p åŒ–ç®€åå¾—ï¼šphi[i]*(p-1); &#125; &#125;&#125; 3. æ±‚å•ä¸ªæ•°çš„æ¬§æ‹‰å‡½æ•° æ—¶é—´å¤æ‚åº¦ O($n^2$)æ—¶é—´å¤æ‚åº¦ O(log n) ç©ºé—´å¤æ‚åº¦ S(1); 123456789101112131415161718192021222324/*æ€»çš„åšæ³•å°±æ˜¯ï¼š å°†reså­˜å‚¨c; ç„¶åæŸ¥æ‰¾cçš„æ‰€æœ‰çº¦æ•°ï¼Œå³èƒ½æ•´æ•°resçš„æ•°ï¼Œå…¨éƒ¨å»é™¤ã€‚ å‰©ä¸‹çš„ä¾¿æ˜¯ä¸cäº’è´¨çš„æ•°ã€‚*/int euler(int c) &#123; int res = c; for (int i = 2; i &lt;= c/i; ++ i) &#123; if (c % i == 0)//æŸ¥æ‰¾cçš„çº¦æ•° &#123; while (c % i == 0) c /= i //åœ¨cä¸­é™¤çº¦æ•°iã€‚ res = res / i * (i - 1); //ç”± res = res - res/i; å¾—æ¥ã€‚ //æ±‚ä¸èƒ½çº¦å»çš„æ•°çš„ä¸ªæ•°ã€‚ &#125; &#125; if (c &gt; 1) res = res / c * (c - 1); //å½“cè¿˜æœ‰å‰©ä½™ï¼Œåˆ™æ˜¯å¤§äº c^(1/2) çš„é‚£ä¸ªçº¦æ•°ï¼Œå°†ä»–åœ¨ç­”æ¡ˆä¸­é™¤å»ã€‚ return res;&#125; æ±‚ç»„åˆæ•° å…¬å¼é€’æ¨ æ—¶é—´å¤æ‚åº¦ O(n^2) ç©ºé—´å¤æ‚åº¦ O(n^2). é€‚ç”¨äº â€œå°è§„æ¨¡â€ã€â€œå°èŒƒå›´â€ çš„æ±‚æ³• C(a,b) = C(a,b-1) + C(a-1,b-1) 12345678for(int i = 0; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= i; j++) &#123; if(!j) f[i][j] = 1; else f[i][j] = f[i-1][j-1]+f[i][j-1]; &#125;&#125; é¢„å¤„ç†æ³• æ—¶é—´å¤æ‚åº¦ O(nlogp) ç©ºé—´å¤æ‚åº¦ O(n).é€‚ç”¨äº â€œä¸­å°è§„æ¨¡â€ ã€â€ä¸­å°èŒƒå›´â€ çš„æ±‚æ³• C(a,b) = a!/(b!*(a-b)!) = a!*b!^-1*(a-b)!^-1 12345678910111213141516171819202122232425262728typedef long long ll;int fact[N],infact[N];//å®šä¹‰int inv(int a,int x,int p)//å¿«é€Ÿå¹‚æ±‚é€†å…ƒ&#123; int res = 1; while(x) &#123; if(x&amp;1) res = (ll) res * a % p; a = (ll) a*a%p;//(ll) x&gt;&gt;=1; &#125; return res;&#125;int main()&#123; fact[0] = infact[0] = 1; for(int i = 1;i&lt;N;i++) &#123; fact[i] = (ll) fact[i-1]*i%p; infact[i] = (ll) infact[i-1]*inv(i,p-2,p)%p; &#125;//é¢„å¤„ç†é˜¶ä¹˜å€¼ï¼Œå’Œé€†å…ƒã€‚ printf(&quot;%d\\n&quot;,(ll) fact[a]*infact[b]%p*infact[a-b]%p);//è¾“å‡ºç»“æœ&#125; Lucaså®šç† â€‹ å¤„ç†å¤§æ¦‚ p åœ¨ 1e5 å†…çš„æ•°æ®é‡ a,bä¸é™é‡ï¼Œä½†æ˜¯åªèƒ½è®¡ç®—20ç»„å·¦å³çš„ æ•°æ® â€‹ é€‚ç”¨äº å¤§èŒƒå›´ï¼Œå°ä¸ªæ•° çš„æ±‚æ³• 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;typedef long long ll;int p;int fp(int a,int x)//å¿«é€Ÿå¹‚&#123; int res = 1; while(x) &#123; if(x &amp; 1) res = (ll) res * a % p; a =(ll) a*a%p; x&gt;&gt;=1; &#125; return res;&#125;int C(int a,int b)//é¢„å¤„ç†é˜¶ä¹˜ï¼Œé€†å…ƒã€‚&#123; int res = 1; for(int i = 1,j = a;i&lt;=b;i++,j--) &#123; res = (ll) res * j % p; res = (ll) res * fp(i,p-2) % p; &#125; return res;&#125;int lucas(ll a,ll b)//Lucaså®šç†&#123; if(a&lt;p &amp;&amp; b&lt;p) return C(a,b);//ç¬¬ä¸€ç§æƒ…å†µæ¯”på°ï¼Œæ‰€ä»¥ç›´æ¥è¾“å‡ºã€‚ return (ll) C(a%p,b%p) * lucas(a/p,b/p) %p;&#125;int main()&#123; ll a,b; cin&gt;&gt; a &gt;&gt; b &gt;&gt; p; cout&lt;&lt;lucas(a,b)&lt;&lt;endl;&#125; å›¾è®ºbfs1234567891011121314151617181920212223242526272829typedef pair&lt;int,int&gt; PII;int g[N][N];//éšœç¢ç‰©int b[N][N];//è¡Œèµ°è·¯å¾„int n,m;queue&lt;PII&gt; qu;int bfs()&#123; memset(b,-1,sizeof(b)); qu.push(&#123;0,0&#125;); b[0][0] = 0; int dx[4] = &#123;0,1,0,-1&#125; ,dy[4] = &#123;1,0,-1,0&#125;; while(!qu.empty()) &#123; auto t = qu.front(); for(int i = 0;i&lt;4;i++) &#123; auto x = t.first + dx[i],y = t.second + dy[i]; if(x &gt;= 0 &amp;&amp; x&lt;n &amp;&amp; y &gt;= 0 &amp;&amp; y&lt;m &amp;&amp; !g[x][y] &amp;&amp; b[x][y] == -1) &#123; b[x][y] = b[t.first][t.second] + 1; qu.push(&#123;x,y&#125;); &#125; &#125; qu.pop(); &#125; return b[n-1][m-1];&#125; Dijkstraç®—æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Dijkstraç®—æ³•ï¼š#include &lt;bits/stdc++.h&gt;using namespace std;const int N = __,M = __,INF = 0x3f3f3f3f;//NèŠ‚ç‚¹ä¸ªæ•°ï¼ŒMè¾¹æ•°typedef pair&lt;int,int&gt; pii;int dist[N];//æ±‚è·ç¦»bool st[N];//æ ‡è®°æ˜¯å¦èµ°è¿‡priority_queue&lt;pii&gt; heap;//é»˜è®¤xæ ¹å †int h[N],e[M],ne[M],w[M],idx;//é“¾æ¥è¡¨å­˜å›¾æ–¹å¼int n,m;//ç‚¹æ•°ï¼Œè¾¹æ•°void add(int a,int b,int c)//a-&gt;b&#123; w[++idx] = c,e[idx] = b,ne[idx] = h[a],h[a] = idx;&#125;int dijkstra(int bg,int ed)&#123; //ç¡®å®šå·¥å…·æ•°ç»„åˆå§‹åŒ– memset(dist,0x3f,sizeof dist); memset(dist,0,sizeof st); //åˆå§‹åŒ– dist[bg] = 0; heap.push(&#123;dist[bg],bg&#125;); while(heap.size()) &#123; auto t = heap.top(); heap.pop(); int sign = t.second; if(st[sign]) continue; st[sign] = true; for(int i = h[sign]; ~i; i = ne[i]) &#123; int j = e[i]; if(dist[j] &gt; dist[sign] + w[i]) &#123; dist[j] = dist[sign] + w[i]; heap.push(&#123;dist[j],j&#125;); &#125; &#125; &#125; return dist[ed];//è¿”å›bgåˆ°edçš„è·ç¦»&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; int bg,ed; cin&gt;&gt;bg&gt;&gt;ed;//bgèµ·å§‹ç‚¹ï¼Œedç»ˆç‚¹ memset(h,-1,sizeof h);//åˆå§‹åŒ–å›¾ while(m--) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,b,c);//a-&gt;bå»ºè¾¹ &#125; int t = dijkstra(bg,ed); if(t == INF) cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; else cout&lt;&lt;t&lt;&lt;endl;&#125; åˆ¤æ–­è´Ÿç¯(dfs+spfa)12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e3+10;vector&lt;pair&lt;int,int&gt; &gt; son[N];int dist[N];int st[N];int n,m;int res;void dfs(int now) &#123; st[now] = 1; for(auto x:son[now]) &#123; int u = x.first,w = x.second; if(dist[u] &gt; dist[now] + w) &#123; dist[u] = dist[now] + w; if(st[u] == 1) &#123; res = true; return; &#125; dfs(u); if(res) return; &#125; &#125; st[now] = 2;&#125; void check() &#123; //æ£€æŸ¥æ¯ä¸ªç‚¹æ˜¯å¦èƒ½åˆ°è¾¾è´Ÿç¯ã€‚ for(int i = 1; i &lt;= n; i++) &#123; if(st[i]) continue; if(res) return; dfs(i); &#125;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 1; i &lt;= m; i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; son[a].push_back(&#123;b,c&#125;); &#125; check(); if(res) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125; äºŒåˆ†å›¾1. bfsæŸ“è‰²æ³•ï¼ˆ0ä»£è¡¨æ— é¢œè‰²ï¼Œ1ã€2åˆ†åˆ«ä»£è¡¨ä¸€ç§é¢œè‰²ï¼‰O(M+N)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+10,M = 2e5+10;typedef pair&lt;int,int&gt; pii;int e[M],ne[M],h[N],idx;int n,m;int st[N];//æ ‡è¯†æ˜¯å¦èµ°è¿‡ã€‚void add(int a,int b) &#123; e[idx] = b,ne[idx] = h[a],h[a] = idx++;&#125;bool bfs(int u) &#123; queue&lt;pii&gt; qu; qu.push(&#123;u,1&#125;); st[u] = 1; while(qu.size()) &#123; auto t = qu.front(); qu.pop(); int ver = t.first,col = t.second; for(int i = h[ver]; ~i; i = ne[i]) &#123; int j = e[i]; if(!st[j]) &#123; st[j] = 3-c0l; qu.push(&#123;j,3-c0l&#125;); &#125; else if(st[j] == col) return false; &#125; &#125; return true;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; memset(h,-1,sizeof h); while(m--) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; add(a,b),add(b,a); &#125; //å¯¹æ¯ä¸ªç‚¹è¿›è¡Œbfsï¼Œå¦‚æœ int flag = true; for(int i = 1; i &lt;= n; i++) &#123; if(!st[i]) &#123; if(!bfs(i)) &#123; flag = false; break; &#125; &#125; &#125;&#125; 2. åŒˆç‰™åˆ©ç®—æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;#define x first#define y secondconst int N = 110;typedef pair&lt;int,int&gt; PII;bool g[N][N];//éšœç¢ç‰©PII match[N][N];//å³ç»„ï¼ˆéåŒ¹é…ç»„ï¼‰çš„å¯¹è±¡bool st[N][N];//åœ¨findè¿‡ç¨‹ä¸­ï¼Œæ ‡è®°int n,m;int dx[] = &#123;-1,0,1,0&#125;, dy[] = &#123;0,-1,0,1&#125;;bool find(int x,int y)&#123; //å¯¹äºå››ä¸ªæ–¹å‘è¿›è¡ŒåŒ¹é… for(int i = 0; i &lt; 4; i ++) &#123; int a = x+dx[i],b = y+dy[i]; if(a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= n &amp;&amp; !g[a][b] &amp;&amp; !st[a][b]) &#123; st[a][b] = true; PII &amp;t = match[a][b]; //å¦‚æœå³ç»„ä¸å­˜åœ¨åŒ¹é…å¯¹è±¡ æˆ–è€… å¯ä»¥æ¢åŒ¹é…å¯¹è±¡ if(t.x == -1 || find(t.x,t.y)) &#123; t = &#123;x,y&#125;; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); while(m--) &#123; int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g[x][y] = true; &#125; int res = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) match[i][j] = &#123;-1,-1&#125;; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j ++) &#123; //å¯¹äºä¸€ä¾§çš„ç»„è¿›è¡ŒåŒ¹é… if((i+j) % 2 &amp;&amp; !g[i][j]) &#123; for(int a = 1; a &lt;= n; a++) for(int b = 1; b &lt;= n; b++) st[a][b] = 0; //æ£€æŸ¥æ˜¯å¦å¯ä»¥åŒ¹é…æˆåŠŸ if(find(i,j)) res++; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,res);&#125; æœ€è¿‘å…¬å…±ç¥–å…ˆLCAå€å¢1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e4+10, M = 2*N;int n,m;int h[N],e[M],ne[M],idx;//depthå­˜å‚¨èŠ‚ç‚¹çš„æ·±åº¦int depth[N],fa[N][16];int q[N];void add(int a,int b) &#123; e[idx] = b,ne[idx] = h[a],h[a] = idx++;&#125;void bfs(int root)//ä½¿ç”¨bfsç®—æ³•è®¡ç®—å‡ºfa&#123; memset(depth,0x3f,sizeof depth); depth[0] = 0,depth[root] = 1; int hh = 0, tt = 0; q[0] = root; while(hh &lt;= tt) &#123; int t = q[hh++]; for(int i = h[t]; ~i; i = ne[i]) &#123; int j = e[i]; if(depth[j] &gt; depth[t] + 1) &#123; //æ±‚æ·±åº¦ depth[j] = depth[t] + 1; q[++tt] = j; //åˆå§‹åŒ–fa[j][0]; fa[j][0] = t; //è¿›è¡Œéå† dpçŠ¶æ€è½¬ç§» for(int k = 1; k &lt;= 15; k++) &#123; fa[j][k] = fa[fa[j][k-1]][k-1]; &#125; &#125; &#125; &#125;&#125;int lca(int a,int b)&#123; //å°†è·ç¦»æ ¹èŠ‚ç‚¹è¿œçš„è®¾ç½®ä¸ºa if(depth[a] &lt; depth[b]) swap(a,b); for(int k = 15; k &gt;= 0; k--) &#123; //äºŒè¿›åˆ¶æ‹¼å‡‘ï¼Œä½¿è¾¾åˆ°åŒä¸€é«˜åº¦ if(depth[fa[a][k]] &gt;= depth[b]) a = fa[a][k]; &#125; if(a == b) return a;//åˆ¤æ–­æ˜¯å¦ä¸ºåŒä¸€ä¸ªç‚¹ã€‚ //å¦åˆ™ï¼ŒåŒæ—¶ä¸Šå‡ç›´åˆ°ç¥–çˆ¶èŠ‚ç‚¹ä¸ºåŒä¸€ä¸ªèŠ‚ç‚¹ã€‚ for(int k = 15; k &gt;= 0; k--) &#123; if(fa[a][k] != fa[b][k]) &#123; a = fa[a][k]; b = fa[b][k]; &#125; &#125; return fa[a][0];&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); int root = 0; memset(h,-1,sizeof h); for(int i = 1; i &lt;= n; i++) &#123; int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); if(b == -1) root = a; else add(a,b),add(b,a); &#125; bfs(root); int p = lca(a,b); return 0;&#125; tarjanæœ€è¿‘å…¬å…±ç¥–å…ˆ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pii;const int N = 10010,M = N*2;int n,m;int h[N],e[M],w[M],ne[M],idx;int dist[N];int res[M];int st[N];int p[N];vector&lt;pii&gt; query[N];void add(int a,int b,int c) &#123; w[idx] = c,e[idx] = b,ne[idx] = h[a],h[a] = idx++;&#125;void dfs(int u,int fa) &#123; for(int i = h[u]; ~i; i = ne[i]) &#123; int j = e[i]; if(j == fa) continue; //åˆ©ç”¨dfsè®¡ç®—distæ¥è¿›è¡Œè®¡ç®—è·ç¦» dist[j] = dist[u] + w[i]; dfs(j,u); &#125;&#125;int find(int x) &#123; if(p[x] != x) p[x] = find(p[x]); return p[x];&#125;void tarjan(int u) &#123; //å½“å‰æœªå›æº¯èŠ‚ç‚¹ st[u] = 1; for(int i = h[u]; ~i; i = ne[i]) &#123; int j = e[i]; if(!st[j]) &#123; tarjan(j); p[j] = u; &#125; &#125; //éœ€è¦cha for(auto item:query[u]) &#123; int y = item.first,id = item.second; if(st[y] == 2) &#123; int p = find(y); //uå’Œyçš„lcaæ˜¯p &#125; &#125; //å·²ç»å›æº¯èŠ‚ç‚¹ st[u] = 2;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; memset(h,-1,sizeof h); for(int i = 1; i &lt; n; i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,b,c),add(b,a,c); &#125; for(int i = 1; i &lt;= m; i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; if(a != b) &#123; query[a].push_back(&#123;b,i&#125;); query[b].push_back(&#123;a,i&#125;); &#125; &#125; //åˆå§‹åŒ–å¹¶æŸ¥é›† for(int i = 1; i &lt;= n; i++) p[i] = i; dfs(1,-1); tarjan(1); return 0;&#125; æœ€å°ç”Ÿæˆæ ‘ kruskal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4+10;struct Edge&#123; int from,to,s;&#125; edge[N];int cnt;int n,p[N],ans;bool cmp(Edge a,Edge b)&#123; return a.s &lt; b.s;&#125;int find(int x)&#123; if(p[x] != x) return p[x] = find(p[x]); else return x;&#125;int main()&#123; cin&gt;&gt;n; int x; for(int i = 1; i &lt;= n; i++) p[i] = i; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) &#123; scanf(&quot;%d&quot;,&amp;x); if(i &gt; j) &#123; edge[++cnt].from = i; edge[cnt].to = j; edge[cnt].s = x; &#125; &#125; sort(edge+1,edge+cnt+1,cmp); for(int i = 1; i &lt;= cnt; i++) &#123; int a = find(edge[i].from); int b = find(edge[i].to); if(a != b) &#123; ans += edge[i].s; p[a] = b; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; å·®åˆ†çº¦æŸx1 - x2 &lt;= n çš„ä¸€ç³»åˆ—æ–¹ç¨‹ï¼Œå¯ä»¥è½¬å˜ä¸ºx2åˆ°x1çš„è·¯å¾„æœ€å¤§ä¸ºnï¼Œç„¶ååˆ¤æ–­è´Ÿç¯ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010,M = 300010,INF = 0x3f3f3f3f;typedef long long ll;int h[N],e[M],ne[M],w[M],idx;int dist[N];bool st[N];int stk[N],cnt[N];int n,m;void add(int a,int b,int c)&#123; w[idx] = c,e[idx] = b,ne[idx] = h[a],h[a] = idx++;&#125;bool spfa()&#123; int hh = 0,tt = 0; memset(dist,-0x3f,sizeof dist); dist[0] = 0; stk[tt++] = 0; st[0] = true; while(hh &lt; tt) &#123; int t = stk[--tt]; st[t] = false; for(int i = h[t]; ~i; i = ne[i]) &#123; int j = e[i]; //dist[j] = a dist[t] = b w[i] = n //a &lt; b + n =&gt; a - b &lt; n if(dist[j] &lt; dist[t] + w[i]) &#123; dist[j] = dist[t] + w[i]; cnt[j] = cnt[t]+1; if(cnt[j] &gt;= n+1) return false; if(!st[j]) &#123; stk[tt++] = j; st[j] = true; &#125; &#125; &#125; &#125; return true;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); memset(h,-1,sizeof h); while(m--) &#123; int x,a,b; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;a,&amp;b); if(x == 1) add(a,b,0),add(b,a,0);//a == b else if(x == 2) add(a,b,1);// else if(x == 3) add(b,a,0); else if(x == 4) add(b,a,1); else add(a,b,0); &#125; for(int i = 1; i &lt;= n; i++) &#123; add(0,i,1); &#125; if(spfa()) &#123; ll res = 0; for(int i = 1; i &lt;= n; i++) &#123; res += dist[i]; &#125; printf(&quot;%lld\\n&quot;,res); &#125; else &#123; puts(&quot;-1&quot;); &#125; return 0;&#125; æ¨¡æ¿æ•°ä½dpæ¨¡æ¿123456789101112131415161718192021222324252627282930int dfs(int posï¼ˆä½ç½®ï¼‰, int preï¼ˆä¸Šä¸€ä¸ªæ•°ï¼‰, int leadï¼ˆå‰å¯¼é›¶ï¼‰, int limitï¼ˆæ˜¯å¦æœ‰é™åˆ¶ï¼‰) &#123; if (!pos) &#123; return å•æ¡é“¾ç»“æŸæ—¶çš„è¿”å›çš„å€¼ï¼› &#125; if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][pre] != -1) return dp[pos][pre]; //è®°å¿†åŒ–æœç´¢ int res = 0, up = limit ? a[pos] : 1 ã€‘; //upè¡¨ç¤ºèƒ½æšä¸¾çš„æœ€é«˜ä½æ•° for (int i = 0; i &lt;= up; i ++) &#123; if (ä¸åˆæ³•æ¡ä»¶) continue; res += dfs(pos - 1, æœªå®šå‚æ•°, lead &amp;&amp; !i, limit &amp;&amp; i == up); &#125; return limit ? res : (lead ? res : dp[pos][sum] = res);&#125;int cal(int x) &#123; memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % è¿›åˆ¶, x /= è¿›åˆ¶; return dfs(len, æœªå®šå‚æ•°, 1, 1);&#125;signed main() &#123; cin &gt;&gt; l &gt;&gt; r; //å…ˆè®¡ç®—1-rçš„æ•°é‡ï¼Œç„¶åè®¡ç®—1-l-1çš„æ•°é‡ï¼Œæœ€åç›¸å‡ã€‚ cout &lt;&lt; cal(r) - cal(l - 1) &lt;&lt; endl;&#125; é«˜ç²¾åº¦åŠ å‡ä¹˜é™¤123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;#define vi vector&lt;int&gt;#define pb(A) push_back(A)vi add(vi A,vi B)&#123; if(A.size() &lt; B.size()) return add(B,A); vi C; int t = 0;//äº¤æ¢åª’ä»‹ for(int i = 0; i &lt; A.size(); i++) &#123; t += A[i]; if(i &lt; B.size()) t += B[i]; C.pb(t%10); t /= 10; &#125; if(t) C.pb(t);//è®°å¾—æ”¶å›ä½™é‡ return C;&#125;int main()&#123; string a,b; cin&gt;&gt;a&gt;&gt;b; vi A,B; for(int i = a.size()-1; i &gt;= 0; i--) A.pb(a[i]-&#x27;0&#x27;); for(int i = b.size()-1; i &gt;= 0; i--) B.pb(b[i]-&#x27;0&#x27;); vi C = add(A,B); for(int i = C.size()-1; i &gt;= 0; i--) cout&lt;&lt;C[i];&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//é«˜ç²¾åº¦å‡æ³•#include &lt;bits/stdc++.h&gt;using namespace std;#define vi vector&lt;int&gt;#define pb(A) push_back(A)bool cmp(vi A,vi B)&#123; if(A.size() != B.size()) return A.size() &lt; B.size(); for(int i = A.size()-1; i &gt;= 0; i--) &#123; if(A[i] != B[i]) &#123; return A[i] &lt; B[i]; &#125; &#125; return 0;&#125;vi sub(vi A,vi B)&#123; if(cmp(A,B)) return sub(B,A); vi C; int t = 0;//äº¤æ¢åª’ä»‹ for(int i = 0; i &lt; A.size(); i++) &#123; t = A[i] - t; if(i &lt; B.size()) t = t-B[i]; C.pb((t+10)%10);//ä¿è¯è´Ÿæ•°çš„æ—¶å€™+10 if(t &lt; 0) t = 1; else t = 0; &#125; while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125;int main()&#123; string a,b; cin&gt;&gt;a&gt;&gt;b; vi A,B; for(int i = a.size()-1; i &gt;= 0; i--) A.pb(a[i]-&#x27;0&#x27;); for(int i = b.size()-1; i &gt;= 0; i--) B.pb(b[i]-&#x27;0&#x27;); if(cmp(A,B)) cout&lt;&lt;&#x27;-&#x27;; vi C = sub(A,B); for(int i = C.size()-1; i &gt;= 0; i--) cout&lt;&lt;C[i];&#125; 1234567891011121314151617181920212223242526272829//é«˜ç²¾åº¦ä¹˜æ³• å¤§æ•°ä¹˜å°æ•°#include &lt;bits/stdc++.h&gt;using namespace std;#define vi vector&lt;int&gt;#define pb(A) push_back(A)vi mul(vi A,int B)&#123; vi C; int t = 0;//äº¤æ¢åª’ä»‹ for(int i = 0; i &lt; A.size(); i++) &#123; t += A[i] * B; C.pb(t%10); t /= 10; &#125; if(t) C.pb(t); while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//æ³¨æ„ä¹˜æ•°æ˜¯0 return C;&#125;int main()&#123; string a; int B; cin&gt;&gt;a&gt;&gt;B; vi A; for(int i = a.size()-1; i &gt;= 0; i--) A.pb(a[i]-&#x27;0&#x27;); vi C = mul(A,B); for(int i = C.size()-1; i &gt;= 0; i--) cout&lt;&lt;C[i];&#125; 12345678910111213141516171819202122232425262728293031323334//é«˜ç²¾åº¦é™¤æ³•#include &lt;bits/stdc++.h&gt;using namespace std;#define vi vector&lt;int&gt;#define pb(A) push_back(A)struct ans&#123; vi C; int lastNumCnt;&#125;;struct ans div(vi A,int B)&#123; vi C; int t = 0;//äº¤æ¢åª’ä»‹ for(int i = 0; i &lt; A.size(); i++)//æ³¨æ„é¡ºåº &#123; t = t*10 + A[i]; C.pb(t/B); t = t%B; &#125; reverse(C.begin(),C.end()); while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//æ³¨æ„ä¹˜æ•°æ˜¯0 return &#123;C,t&#125;;&#125;int main()&#123; string a; int B; cin&gt;&gt;a&gt;&gt;B; vi A; for(int i = 0; i &lt; a.size(); i++) A.pb(a[i]-&#x27;0&#x27;);//æ³¨æ„é¡ºåº auto res = div(A,B); for(int i = res.C.size()-1; i &gt;= 0; i--) cout&lt;&lt;res.C[i]; cout&lt;&lt;&#x27;\\n&#x27;&lt;&lt;res.lastNumCnt;&#125; åšé¢˜å°ç»“ åšå¼ˆè®ºé¢˜ åªçœ‹ç¬¬ä¸€æ­¥ï¼Œåªçœ‹ç¬¬ä¸€æ­¥ï¼Œåªçœ‹ç¬¬ä¸€æ­¥ï¼Œç¬¬ä¸€æ­¥å†³èƒœè´Ÿï¼ WAäº† å¦‚æœæ„Ÿè§‰æ²¡é”™ä½†æ˜¯ä»£ç æ²¡è¿‡ï¼Œæœ€å¥½é‡æ–°è¯æ˜ä¸€ä¸‹æ€è·¯æ˜¯å¦æ­£ç¡®ã€‚ å¦‚æœè¯æ˜å®Œæˆåè¿˜æ˜¯æ­£ç¡®ï¼Œé‚£å°±æµ‹è¯•ä¸€ä¸‹ç‰¹æ®Šæ ·ä¾‹ï¼Œæˆ–è€…æ£€æŸ¥ä¸€ä¸‹ç»†èŠ‚ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºï¼ŒèŒƒå›´ï¼Œé¢˜ç›®ä¸­çš„ç‰¹æ®Šæ¡ä»¶ç­‰ã€‚ ç­¾åˆ°é¢˜ è¿‡çš„äººå¾ˆå¤šçš„é¢˜ï¼Œä¸€èˆ¬æ˜¯ç»“è®ºé¢˜ã€‚ å­—ç¬¦ä¸²å­ä¸²ä¸ªæ•° n*(n+1)/2","categories":[{"name":"å­¦ä¹ ","slug":"å­¦ä¹ ","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"ç®—æ³•","slug":"å­¦ä¹ /ç®—æ³•","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"CKH"}],"categories":[{"name":"æŠ€æœ¯æ•™ç¨‹","slug":"æŠ€æœ¯æ•™ç¨‹","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"},{"name":"æ–°æ‰‹æ•™ç¨‹","slug":"æŠ€æœ¯æ•™ç¨‹/æ–°æ‰‹æ•™ç¨‹","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/"},{"name":"å­¦ä¹ ","slug":"å­¦ä¹ ","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"ç®—æ³•","slug":"å­¦ä¹ /ç®—æ³•","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"æ•™ç¨‹","slug":"æ•™ç¨‹","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}